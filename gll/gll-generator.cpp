/*
 * This source code is supplied "AS IS". The Author disclaims
 * all warranties, expressed or implied including, without limitation,
 * the warranties of merchantability and of fitness for any purpose.
 * The Author assumes no liability for direct, indirect, incidental,
 * special, exemplary, or consequential damages, which may result from
 * the use of the computer program, even if advised of the
 * possibility of such damage.
 * This source code is provided with all faults, and the entire risk 
 * of satisfactory quality, performance, accuracy, and effort is with
 * the user.
 */

//I wouldn't be surprised if there are bugs in the below code.

#include "pgraph.h"

#define IDENT "      "

void print_match_against(Grammar* grmr, const vector<Context>& ctxen, bool isINITIAL=false){
  for (int i=0;i<ctxen.size();++i){
    if (i!=0) printf(" ||\n"IDENT"      ");
    if (ctxen[i].isEndOfInput()) {
      if (isINITIAL) printf("token == EOF");
      else {
        // Scary. Here we are dealing with a case when THE REST OF A RULE is NULLABLE.
        // We really need a FOLLOW set for the rule, but we don't generate it, so ...
        // (Having a FOLLOW set is really an optimization, IMHO, so we can do without it for a while...) 
        printf("true"); 
      }
    } else {
      printf("doMatch(\"%s\", token)", ctxen[i].getMatcher().c_str()); //ctxen[i].return_stack_string().c_str()
    }
  }
  if (ctxen.size() == 0) printf("FATAL: THERE IS NO WAY FOR THIS STATE TRANSITION TO OCCUR!");
}

//I should really do more corrections here, but meh. Will do for now.
string normalize_rule_name(string rulename){
  string ret;
  for (int i=0;i<rulename.size();++i)
    if (rulename[i]!='$')
      ret += rulename[i];
  return ret;
}

/*
 * Code generated by this thing could probably be SERIOUSLY be OPTIMIZED by 
 * SOMETHING FUNKY to remove duplicate comparisons or even merge transitions.
 */
void printTransitionsForker(Grammar* grmr, vector<Context>& ctxen, const char* rulename, const string& prefix, const string& matcher){
  for (int i=0;i<ctxen.size();++i){
    //Some may think that this means that nullables at the end of rules would be ignored, but they would have made an incorrect assumption.
    //Grammar::step_NR does not do recursive lookup when building next contexen, so that should never happen.
    //(NR stands for NON-RECURSIVE!)
    //The difference between recursive and non-recursive is rather simple. 
    //The output of the recursive version only contains terminals (including $$eof).
    //The output of the non-recursive version, on the other hand, contains non-terminals whereever it is possible to have them.
    if (ctxen[i].isEndOfInput()) { //.isEndOfRule() may have been a better name
      printf(IDENT"  // %s%s [.]\n", prefix.c_str(), matcher.c_str());
      if (i==ctxen.size()-1){
        printf(IDENT"  goto DO_POP;\n");
      } else { //Should never happen, but I'll put this here anyway.
        printf(IDENT"  work_set.push_back(FooBar(DO_POP, c_u));\n"); //We don't want to be polluting current_set with this nonsense.
      }
    } else {
      printf(IDENT"  if (");
      //first_set does a recursive lookup in this position. 
      //Note that there is no need for separate handling of FIRST or FOLLOW sets __within a rule__.
      //The FOLLOW set generated (if any) is also _minimal_ for this particular position.
      //However, if the entire rest of the rule is nullable... see print_match_against.
      print_match_against(grmr, grmr->first_set(ctxen[i])); 
      printf(") {\n");
      printf(IDENT"    // %s%s [.] %s ...\n", prefix.c_str(), matcher.c_str(), ctxen[i].getMatcher().c_str());
      if (matcher_is_terminal(ctxen[i].getMatcher())){
        printf(IDENT"    ADD_NEXT(STATE_%s_%i, c_u);\n", rulename, ctxen[i].getrei().uniqueid);
      } else {
        printf(IDENT"    ADD_NOW(STATE_%s_%i_ENTRY, c_u);\n", rulename, ctxen[i].getrei().uniqueid);
      }
      printf(IDENT"  }\n");
    }
  }
  printf(IDENT"  break;\n");
  if (ctxen.size() == 0) printf("FATAL: STATE HAS NO TRANSTITIONS AWAY FROM IT!");
}

void doRuleCont(Grammar* grmr, const char* rulename, const Context& ctx, string prefix, vector<string>* now_set){
  if (ctx.isEndOfInput()) return;
  
  char state_name_buf[255];
  sprintf(state_name_buf, "%s_%i", rulename, ctx.getrei().uniqueid);
  string state_name(state_name_buf);
  
  //This could happen due to loops in a rule (yes, we allow loopy rules.)
  //Since we don't want to print the same state twice, return.
  if (contains(*now_set, state_name)) return; 
  now_set->push_back(state_name);
  
  string matcher(ctx.getMatcher());
  
  vector<Context> ctxen = grmr->step_NR(ctx);
  
  if (!matcher_is_terminal(matcher)){ 
    //Separate _ENTRY states otherwise we'd screw up on left-recursive grammars.
    now_set->push_back(state_name+"_ENTRY");
    printf(IDENT"STATE(%s_ENTRY) // %s[.] %s ...\n", state_name.c_str(), prefix.c_str(), matcher.c_str());
    printf(IDENT"  c_u = gss_create(STATE_%s, c_u, token_position, &gss, &P_set);\n", state_name.c_str());
    printf(IDENT"  goto STATE_%s;\n", normalize_rule_name(matcher).c_str());
  }
  printf(IDENT"STATE(%s) // %s%s [.] ...\n", state_name.c_str(), prefix.c_str(), matcher.c_str());
  printTransitionsForker(grmr, ctxen, rulename, prefix, matcher);
  
  for (int i=0;i<ctxen.size();++i){
    doRuleCont(grmr, rulename, ctxen[i], prefix+matcher+" ", now_set);
  }
}

/*
 * GLL Parser Generator
 * Generated parsers have worst case O(n^3) time.
 *
 * E.g. A O(n^2) parser is generated for the non-LL(1) grammar:
 * start -> expr
 * expr -> "x" expr "x"
 * expr -> "x"
 */

int main(){
  Grammar grmr;
  vector<Rule*> rules;
  
  rules.push_back(grmr.newRule("$expr"));
  rules.push_back(grmr.newRule("$A"));
  rules.push_back(grmr.newRule("$B"));
  rules.push_back(grmr.newRule("$C"));
  
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$A"));
    grammar_rule.leafs.push_back(Node::strwrap("a"));
    grmr.getRule("$expr")->registerRule(grammar_rule);
  }
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$C"));
    grammar_rule.leafs.push_back(Node::strwrap("c"));
    grmr.getRule("$expr")->registerRule(grammar_rule);
  }
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$$null"));
    grmr.getRule("$expr")->registerRule(grammar_rule);
  }
  
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$B"));
    grammar_rule.leafs.push_back(Node::strwrap("b"));
    grmr.getRule("$A")->registerRule(grammar_rule);
  }
  
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$expr"));
    grammar_rule.leafs.push_back(Node::strwrap("x"));
    grmr.getRule("$B")->registerRule(grammar_rule);
  }
  
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$B"));
    grammar_rule.leafs.push_back(Node::strwrap("d"));
    grmr.getRule("$C")->registerRule(grammar_rule);
  }
  {
    Node grammar_rule;
    grammar_rule.leafs.push_back(Node::strwrap("$A"));
    grammar_rule.leafs.push_back(Node::strwrap("e"));
    grmr.getRule("$C")->registerRule(grammar_rule);
  }
  
  Rule* start = grmr.getRule("$expr");
  
  printf("#include \"gll_library.hpp\"");
  
  //User defined functions
  printf("\n"
         "\n"
         "\n//USER DEFINED AREA START"
         "\n#include <cstdio>"
         "\n#include <ctype.h>"
         "\nint next_token(){"
         "\n  int ret = getchar();"
         "\n  while (isspace(ret)) ret=getchar();"
         "\n  return ret;"
         "\n}"
         "\nbool doMatch(const char* matcher, int token){"
         "\n  return matcher[0] == token;"
         "\n}"
         "\nvoid gll_parser();"
         "\nint main(){gll_parser();}"
         "\n//USER DEFINED AREA END"
         "\n"
         "\n");
  
  printf("\nvoid gll_parser(){"
         "\n#define EOF (-1)"
         "\n  DirectedGraph<Quux> gss;"
         "\n  Quux c_u(STATE_INITIAL, 0);"
         "\n  Quux u_nought(-1, -1);"
         "\n  gss.join(c_u, u_nought);"
         "\n  vector<FooBar> current_set, next_set, work_set;"
         "\n  current_set.push_back(FooBar(STATE_INITIAL, c_u));"
         "\n  work_set = current_set;"
         "\n  P_set_type P_set;"
         "\n  int token;"
         "\n  int token_position = -1;"
         "\n  bool debug=true;"
         //"\n  jmp_buf pop_jmp_env;"
         "\n"
         "\n  while (true){"
         "\n    token = next_token();"
         "\n    token_position++;"
         "\n    while (work_set.size() != 0) {"
         "\n      int state = work_set.back().state;"
         "\n      c_u = work_set.back().c_u;"
         "\n      work_set.pop_back();"
         "\n      switch (state){");
  {
    string normalrulename = normalize_rule_name(start->getRulename());
    printf("\n"IDENT"STATE(INITIAL) // start -> [.] %s\n", start->getRulename().c_str());
    printf(IDENT"  if (");
    print_match_against(&grmr, grmr.startRule(start), /*isINITIAL=*/true); //RECURSIVE lookup. $$eof may be generated if start is nullable.
    printf(") {\n"
           IDENT"    goto STATE_%s;\n"
           IDENT"  }\n"
           IDENT"  break;\n",
           normalrulename.c_str());
  }
  
  vector<string> all_names;
  
  for (int rulenum=0;rulenum<rules.size();++rulenum){
    vector<string> now_set;
    Rule* rule = rules[rulenum];
    string normalized_rulename_str = normalize_rule_name(rule->getRulename());
    const char* rulename = normalized_rulename_str.c_str();
    printf(IDENT"STATE(%s) // %s\n", rulename, rule->getRulename().c_str());
    vector<Context> ctxen_nr = grmr.startRule_NR(rule);
    string ARROW = " ->";
    printTransitionsForker(&grmr, ctxen_nr, rulename, rule->getRulename(), ARROW);
    for (int i=0;i<ctxen_nr.size();++i){
      doRuleCont(&grmr, rulename, ctxen_nr[i], rule->getRulename()+ARROW+" ", &now_set);
    }
    append(all_names, now_set);
  }
  
  printf("\n"IDENT"exit(-2);"
         "\n"IDENT"case DO_POP:"
         "\n"IDENT"DO_POP:"
         "\n"IDENT"  if (debug) printf(\"DO_POP(%%i)\\n\", token_position);"
         "\n"IDENT"  if (c_u != u_nought){"
         "\n"IDENT"    P_set[c_u].push_back(token_position);"
         "\n"IDENT"    vector<Quux> children = gss.next(c_u);"
         "\n"IDENT"    for (int i=0;i<children.size();++i){"
         "\n"IDENT"      FooBar fb(c_u.state, children[i]);"
         "\n"IDENT"      ADD_NOW(c_u.state, children[i]);"
         "\n"IDENT"    }"
         "\n"IDENT"  }"
         "\n"IDENT"}"
         "\n");
  printf("\n    }"
         "\n    if (token == EOF) break;"
         "\n    if (next_set.size() == 0) printf(\"Failure at position %%i\\n\", token_position);"
         "\n"
         "\n    current_set = next_set;"
         "\n    work_set = next_set;"
         "\n    next_set = vector<FooBar>();"
         "\n  }"
         "\n"
         "\n  if (debug){"
         "\n    gss.dot_dump();"
         "\n    for (int i=0;i<current_set.size();++i)"
         "\n      printf(\"%%s\\n\", current_set[i].to_string().c_str());"
         "\n  }"
         "\n"
         "\n  FooBar success_indicator(STATE_INITIAL, u_nought);"
         "\n  if (contains(current_set, success_indicator)) printf(\"Success!\\n\");"
         "\n  else printf(\"Failure at end!\\n\");"
         "\n"
         "\n}");
  
  printf("\n\n\nenum ___STATE___ {\n  STATE_INITIAL,");
  for (int rulenum=0;rulenum<rules.size();++rulenum){
    Rule* rule = rules[rulenum];
    string normalized_rulename_str = normalize_rule_name(rule->getRulename());
    const char* rulename = normalized_rulename_str.c_str();
    printf("\n  STATE_%s,", rulename);
  }
  for (int i=0;i<all_names.size();++i){
    printf("\n  STATE_%s,", all_names[i].c_str());
  }
  printf("\n  DO_POP"
         "\n};"
         "\n");
  
}